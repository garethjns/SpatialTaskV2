function obj = findIntegrators(obj, mn, thresh)
% Look through available subject fits and tabulate pValues (and
% logical based on thresh):
% A_Ar: Uses A in A response (not really needed)
% V_Ar: Uses V in A response
% AV_Ar: Uses AV in A reponse
% A_Vr: Uses A in V response
% V_Vr: Uses V in V response (not really needed)
% AV_Vr: Uses AV in V reponse
%
% Then create following logicals:
% Ar_useV: V used for aud resp - semi
% Ar_useAV: AV used for aud resp - semi
% Ar_useVAV: V or AV used in aud resp - full
% Vr_useA: A Used for vis resp - semi
% Vr_useAV: AV used for vis resp - sem
% Vr_useAAV: A or AV used for vis resp - full
% AVr_useVAVAAV: (A or AV used in V) and (V or AV used in A resp)

% Set significance threshold if not specified
if ~exist('thresh', 'var')
    thresh = 0.05;
end

% Get the selected model to use
[mn, mfn, mod] = obj.setMod(mn);

fns = fieldnames(mod);
nSubs = length(fns);

% For each subject, mark A int, V int, AV inte
vars = {(1:nSubs)', 'Subject', 'Subject number'; ...
    NaN(nSubs,1), 'cA_Ar', 'Val: A stim to A resp'; ...
    NaN(nSubs,1), 'cV_Ar', 'Val: V stim to A resp'; ...
    NaN(nSubs,1), 'cAV_Ar', 'Val: AV inter to A resp'; ...
    NaN(nSubs,1), 'cA_Vr', 'Val: A stim to V resp'; ...
    NaN(nSubs,1), 'cV_Vr', 'Val: V stim to V resp'; ...
    NaN(nSubs,1), 'cAV_Vr', 'Val: AV inter to A resp'; ...
    NaN(nSubs,1), 'pA_Ar', 'Sig: A stim to A resp'; ...
    NaN(nSubs,1), 'pV_Ar', 'Sig: V stim to A resp'; ...
    NaN(nSubs,1), 'pAV_Ar', 'Sig: AV inter to A resp'; ...
    NaN(nSubs,1), 'pA_Vr', 'Sig: A stim to V resp'; ...
    NaN(nSubs,1), 'pV_Vr', 'Sig: V stim to V resp'; ...
    NaN(nSubs,1), 'pAV_Vr', 'Sig: AV inter to V resp'; ...
    NaN(nSubs,1), 'rA_A_Ar', 'Ratio:  cA_Ar  to cA_Ar (==)'; ...
    NaN(nSubs,1), 'rV_A_Ar', 'Ratio: cV_Ar  to cA_Ar'; ...
    NaN(nSubs,1), 'rAV_A_Ar', 'Ratio: cVA_Ar to cA_Ar'; ...
    NaN(nSubs,1), 'rA_V_Vr', 'Ratio:  cA_Vr  to cV_Vr'; ...
    NaN(nSubs,1), 'rV_V_Vr', 'Ratio:  cV_Vr  to cV_Vr (==)'; ...
    NaN(nSubs,1), 'rAV_V_Vr', 'Ratio: cAV_Vr to cV_Vr'; ...
    NaN(nSubs,1), 'A_Ar', 'Uses A in A response'; ...
    NaN(nSubs,1), 'V_Ar', 'Uses V in A response'; ...
    NaN(nSubs,1), 'AV_Ar', 'Uses AV in A reponse'; ...
    NaN(nSubs,1), 'A_Vr', 'Uses A in V response'; ...
    NaN(nSubs,1), 'V_Vr', 'Uses V in V response'; ...
    NaN(nSubs,1), 'AV_Vr', 'Uses AV in V reponse'; ...
    NaN(nSubs,1), 'Ar_useV', 'V used for aud resp'; ...
    NaN(nSubs,1), 'Ar_useAV', 'AV used for aud resp'; ...
    NaN(nSubs,1), 'Ar_useVAV', 'V or AV used for aud resp'; ...
    NaN(nSubs,1), 'Vr_useA', 'A Used for vis resp '; ...
    NaN(nSubs,1), 'Vr_useAV', 'AV used for vis respr'; ...
    NaN(nSubs,1), 'Vr_useAAV', 'A or AV used for vis resp'; ...
    NaN(nSubs,1), 'AVr_useVAVAAV', 'Vr_useAAV & Ar_useVAV'};

t = table(vars{:,1}, ...
    'VariableNames', vars(:,2));
t.Properties.VariableDescriptions = vars(:,3);

for s = 1:nSubs
    
    sIdx = t.Subject==s;
    t.cA_Ar(sIdx) = ...
        mod.(fns{s}).(['A', mfn]).Coefficients.Estimate(2);
    t.cV_Ar(sIdx) = ...
        mod.(fns{s}).(['A', mfn]).Coefficients.Estimate(3);
    t.cAV_Ar(sIdx) = ...
        mod.(fns{s}).(['A', mfn]).Coefficients.Estimate(4);
    t.pA_Ar(sIdx) = ...
        mod.(fns{s}).(['A', mfn]).Coefficients.pValue(2);
    t.pV_Ar(sIdx) = ...
        mod.(fns{s}).(['A', mfn]).Coefficients.pValue(3);
    t.pAV_Ar(sIdx) = ...
        mod.(fns{s}).(['A', mfn]).Coefficients.pValue(4);
    
    t.cA_Vr(sIdx) = ...
        mod.(fns{s}).(['V', mfn]).Coefficients.Estimate(2);
    t.cV_Vr(sIdx) = ...
        mod.(fns{s}).(['V', mfn]).Coefficients.Estimate(3);
    t.cAV_Vr(sIdx) = ...
        mod.(fns{s}).(['V', mfn]).Coefficients.Estimate(4);
    t.pA_Vr(sIdx) = ...
        mod.(fns{s}).(['V', mfn]).Coefficients.pValue(2);
    t.pV_Vr(sIdx) = ...
        mod.(fns{s}).(['V', mfn]).Coefficients.pValue(3);
    t.pAV_Vr(sIdx) = ...
        mod.(fns{s}).(['V', mfn]).Coefficients.pValue(4);
    
end

% Simple logicals
t.A_Ar = t.pA_Ar < thresh;
t.V_Ar = t.pV_Ar < thresh;
t.AV_Ar = t.pAV_Ar < thresh;
t.A_Vr = t.pA_Vr < thresh;
t.V_Vr = t.pV_Vr < thresh;
t.AV_Vr = t.pAV_Vr < thresh;

% Simple integrator definitions
t.Ar_useV = t.V_Ar;
t.Vr_useA = t.A_Vr;
t.Ar_useAV = t.AV_Ar;
t.Vr_useAV = t.AV_Vr;

% More complex integrator definitions
t.Ar_useVAV = t.V_Ar | t.AV_Ar; %
t.Vr_useAAV = t.A_Vr | t.AV_Vr;
t.AVr_useVAVAAV = t.Ar_useVAV & t.Vr_useAAV;

% Calculate ratios
t.rA_A_Ar = t.cA_Ar   ./ t.cA_Ar;
t.rV_A_Ar = t.cV_Ar   ./ t.cA_Ar;
t.rAV_A_Ar = t.cAV_Ar ./ t.cA_Ar;
t.rA_V_Vr = t.cA_Vr   ./ t.cV_Vr;
t.rV_V_Vr = t.cV_Vr   ./ t.cV_Vr;
t.rAV_V_Vr = t.cAV_Vr ./ t.cV_Vr;

% Save table
obj.integrators.(mn) = t;

end